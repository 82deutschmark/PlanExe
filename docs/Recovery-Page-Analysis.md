# Recovery Page Analysis: Understanding the "Assembly" Pattern

**Date**: 2025-10-26  
**Purpose**: Clarify what the Recovery page actually does and identify similar assembly patterns in the codebase.

---

## What the Recovery Page Actually Is

The "Recovery" page is **misnamed**. It's not primarily about recovery—it's an **Assembly Workspace** that:

1. **Fetches database-stored artifacts** from the `plan_content` table
2. **Assembles them into meaningful views** without re-running the Luigi pipeline
3. **Provides live monitoring** of ongoing pipeline execution via WebSocket
4. **Enables artifact exploration** with preview, download, and filtering capabilities

### Why "Recovery"?

The name comes from its **secondary capability**: when the Luigi pipeline's `ReportTask` fails to generate the final HTML report, this page can still display all the intermediate outputs that were successfully written to the database. But that's a **fallback scenario**, not its primary purpose.

---

## What the Page Does (High-Level)

### Primary Functions

1. **Database-First Artifact Browser**
   - Displays all artifacts written to `plan_content` during pipeline execution
   - Groups artifacts by pipeline stage (Setup, Analysis, Strategic Planning, etc.)
   - Provides search, filtering by stage/type, and list/stage view toggles
   - Enables preview and download of individual artifacts

2. **Live Pipeline Monitoring**
   - WebSocket connection for real-time progress updates
   - Stage timeline showing which pipeline stages are active/completed
   - Live LLM reasoning streams showing what the AI is currently thinking
   - Pipeline logs terminal with stdout/stderr from Luigi tasks

3. **Report Assembly**
   - Primary: Displays the canonical HTML report generated by `ReportTask`
   - Fallback: Assembles a report from database artifacts if `ReportTask` fails
   - Preview capability for markdown, JSON, HTML, and text artifacts

4. **Plan Management**
   - Display plan metadata (status, progress, model used)
   - Relaunch capability to re-run the plan with different parameters
   - Connection status monitoring (WebSocket vs polling fallback)

---

## Component Architecture

### Frontend Structure (`planexe-frontend/src/app/recovery/`)

```
recovery/
├── page.tsx                    # Main layout orchestrator
├── useRecoveryPlan.ts          # Data fetching & WebSocket hook (967 lines!)
├── components/
│   ├── RecoveryHeader.tsx      # Top bar with plan info & controls
│   ├── StageTimeline.tsx       # Visual pipeline stage progress
│   ├── ArtefactList.tsx        # Wrapper around FileManager
│   ├── ArtefactPreview.tsx     # Preview modal for artifacts
│   ├── ReportPanel.tsx         # HTML report display
│   ├── LiveStreamPanel.tsx     # Active LLM reasoning stream
│   └── StreamHistoryPanel.tsx  # Historical LLM interactions
```

### Key Shared Components

- **`FileManager.tsx`** (495 lines): The core artifact browser with:
  - Client-side ZIP bundling (custom implementation!)
  - Search and filtering
  - List/Stage view modes
  - Preview/Download actions

### Backend Endpoints Used

| Endpoint | Purpose |
|----------|---------|
| `GET /api/plans/{id}` | Fetch plan metadata |
| `GET /api/plans/{id}/artefacts` | Get artifact list from `plan_content` table |
| `GET /api/plans/{id}/report` | Get canonical HTML report |
| `GET /api/plans/{id}/fallback-report` | Assemble report from database if primary fails |
| `GET /api/plans/{id}/files/{filename}` | Download individual artifact |
| `WebSocket /api/plans/{id}/stream` | Real-time progress updates |

---

## Other "Assembly" Pages in the Codebase

Based on the analysis, there are **three assembly patterns** in PlanExe:

### 1. **Artifact Assembly** (Recovery Page)
- **Location**: `/recovery?planId=xxx`
- **Assembles**: Database artifacts into browsable/searchable interface
- **Primary Data Source**: `plan_content` table
- **Pattern**: Fetch metadata, display grouped/filtered views, enable download/preview

### 2. **Fallback Report Assembly** (Backend-Only)
- **Location**: `GET /api/plans/{plan_id}/fallback-report`
- **Function**: `_assemble_fallback_report()` in `api.py`
- **Assembles**: HTML report from database artifacts when `ReportTask` fails
- **Pattern**: 
  - Fetch expected filenames from `EXPECTED_REPORT_FILENAMES`
  - Match against `plan_content` records
  - Generate HTML from available content
  - Mark missing sections
  - Calculate completion percentage

### 3. **Live Document Assembly** (Backend-Only)
- **Location**: `GET /api/plans/{plan_id}/assembled-document`
- **Assembles**: Live markdown document from completed task outputs
- **Pattern**:
  - Fetch all `plan_content` records
  - Extract text/markdown from each
  - Build sequential markdown document with sections
  - Return structured data for viewer

---

## What Makes It "Assembly"?

The assembly pattern in PlanExe has these characteristics:

1. **Database-First**: Data comes from the `plan_content` table, not files
2. **No Re-execution**: Assembles from what's already been generated
3. **Resilient**: Works even if the pipeline failed partway through
4. **Progressive**: Updates in real-time as new content is written
5. **Multi-View**: Same data can be presented in different formats

---

## Key Insights

### The Recovery Page Should Be Renamed

Suggested names:
- **"Plan Workspace"** (most accurate)
- **"Pipeline Monitor"** (emphasizes live aspect)
- **"Artifact Explorer"** (emphasizes browsing)

The word "Recovery" misleads users into thinking it's only for failed plans.

### The Page Is Overloaded

The recovery page currently does **six distinct jobs**:

1. Live pipeline monitoring
2. Artifact browsing
3. Report viewing
4. LLM reasoning inspection
5. WebSocket connection management
6. Plan relaunching

This violates SRP at the feature level. Consider splitting into:
- **Live Monitor**: Real-time progress, logs, LLM streams
- **Artifact Browser**: Search, filter, download artifacts
- **Report Viewer**: Display final report (canonical or assembled)

### FileManager Is Reusable

The `FileManager` component is already designed to be reusable:
- Used via `RecoveryArtefactPanel` wrapper
- Could be used in other contexts (e.g., a dedicated "Files" page)
- Contains sophisticated client-side ZIP bundling

### Missing Opportunities

1. **No "Plan History" Page**: View all past plans in a list
2. **No "Artifact Diff"**: Compare artifacts between plan runs
3. **No "Stage Inspector"**: Deep-dive into a specific pipeline stage

---

## Recommendations

### Immediate (Documentation Only)

1. **Rename the page** from "Recovery" to "Plan Workspace" in UI
2. **Update route** from `/recovery` to `/workspace` or `/plan`
3. **Document the assembly pattern** as an architectural principle

### Short-Term (Refactor)

1. **Split `useRecoveryPlan.ts`** (967 lines → multiple focused hooks)
2. **Create reusable hooks**:
   - `useArtifacts()` - Artifact fetching/filtering
   - `usePipelineMonitor()` - WebSocket progress tracking
   - `useLLMStreams()` - LLM reasoning display
3. **Extract FileManager filters** into a shared utility

### Long-Term (New Features)

1. **Create dedicated "Plans" list page** using the same assembly pattern
2. **Build "Stage Detail" page** showing all artifacts/logs for one stage
3. **Add artifact comparison** between plan runs
4. **Create shareable plan reports** with public URLs

---

## Conclusion

The "Recovery" page is actually a **comprehensive plan assembly workspace** that demonstrates the database-first architecture of PlanExe. It's not primarily about recovery—it's about providing a unified interface to monitor, explore, and interact with plan execution in real-time.

The assembly pattern (database → metadata → grouped views → actions) is used in three places:
1. Recovery page artifact browser
2. Fallback report assembly endpoint
3. Live document assembly endpoint

This pattern should be:
- **Documented** as a core architectural principle
- **Reused** for new features (plan history, stage inspector)
- **Renamed** to reflect its actual purpose ("Workspace" not "Recovery")
